#! /bin/sh

# NOTE: you may need to adjust the references to /usr/local/... below
#	(or remove them if they're not needed on your system).
#	You may need to add something like "-Olimit 2000" to the -O
#	processing below or change it to something more suitable for your
#	system.  See also the comments starting with ### below.

#	Note that with some shells, invocations of the form
#		CFLAGS='system-specific stuff' fc ...
#	may be useful as way to pass system-specific stuff to the C compiler.
#	The script below simply appends to the initial CFLAGS value.

prefix="@prefix@"
exec_prefix="@exec_prefix@"
bindir="@bindir@"
includedir="@includedir@"
PATH="${bindir}:$PATH"

show_help2 () {
	$F2C -v
}

show_help1 () {
MORE=more
if which less >/dev/null; then MORE=less; fi
$MORE <<EOF
	usage:	f77 [options] files [-l library]
	Options:
		-o objfile	Override default executable name a.out.
		-a		use automatic variable storage (on the stack)
				by default -- rather than static storage
		-c		Do not call linker, leave relocatables in *.o.
		-C		Check that subscripts are in bounds.
		-S		leave assembler output on file.s
		-L libdir	(passed to ld)
		-l library	(passed to ld)
		-u		complain about undeclared variables
		-w		omit all warning messages
		-w66		omit Fortran 66 compatibility warning messages
		files		FORTRAN source files ending in .f .
				FORTRAN with cpp preprocessor directives
					ending in .F .
				C source files ending in .c .
				Assembly language files ending in .s .
				efl source files ending in .e .
				RATFOR files ending in .r .
				Object files ending in .o .
				Shared libraries ending in .so .

				f2c prototype files ending in .P ; such
				files only affect subsequent files.
		-D def		passed to C compiler (for .c files)
				or to cpp (for .F files)
		-I includepath	passed to C compiler (for .c files)
				or to cpp (for .F files), and to f2c
		-m xxx		passed to C compiler as -mxxx
		-N tnnn		allow nnn entries in table t
		-P		emit .P files
		-r8		promote real to double precision and
				complex to double complex
		-s		strip executable
		-trapuv		Initialize floating-point variables to
				signaling NaNs (on machines with IEEE
				arithmetic) unless they appear in save,
				common, or data statements.  Initialize
				other kinds of variables to values that
				may attract attention if used without
				being assigned proper values.
		-U def		passed to C compiler (for .c files)
				or to cpp (for .F files) to remove def
		-v		show current f2c version
		--version	same as -v
	C options:
		--keep-c-files	Preserve the C files generated by F2C.
		--no-sharp-line	Store line information from the C file, not
				from the fortran file.
EOF
}

s=/tmp/stderr_$$
t=/tmp/f77_$$.o
### On some systems (e.g., IRIX), -common prevents complaints
### about multiple definitions of COMMON blocks.
#CC=${CC_f2c:-'cc -common'}
CC=${CC_f2c:-'@CC@'}
EFL=${EFL:-efl}
EFLFLAGS=${EFLFLAGS:-'system=portable deltastno=10'}
RATFOR=${RATFOR:-ratfor}
RFLAGS=${RFLAGS:-'-6&'}
F2C=${F2C:-f2c}
show_fc_help=0
if test -z "$*"; then
	show_help1
	exit 1
fi
case $1 in
	--help)		show_help1; exit 0;;
	--version)	show_help2; exit 0;;
	'-?')		show_help1; exit 0;;
	-h)		show_help1; exit 0;;
	-v)		show_help2; exit 0;;
esac
F2CFLAGS=${F2CFLAGS:='-ARw8 -Nn802 -Nq300 -Nx400'}
CPP=${CPP:-/lib/cpp}
rc=0
trap "rm -f $s $t; exit \$rc" 0
OUTF=a.out
OUTO=
cOPT=1
CPPFLAGS=${CPPFLAGS:-"-I${includedir}"}
CFLAGSF2C=${CFLAGSF2C:-"-I${includedir}"}
CFLAGS=${CFLAGS:-' -g -O2'}
OFILES=
trapuv=
strip=
LIBS="-L${exec_prefix}/lib -lf2c  -lm"
FILES=
while
	test X"$1" != X

do
	case "$1"
	in
	-a)	F2CFLAGS="$F2CFLAGS -a"
		shift;;

	-C)	F2CFLAGS="$F2CFLAGS -C"
		shift;;

	-c)	cOPT=0
		shift
		;;

	--keep-c-files)
		keep_c_files=1
		shift
		;;

	--no-sharp-line)
		F2CFLAGS="$F2CFLAGS -nl"
		shift
		;;

	-D)	CPPFLAGS="$CPPFLAGS -D$2"
		shift 2
		;;

	# Typical flags for gcc, such as -fPIC, -fpie, -fshort-double, ...
	-f*)	CFLAGS="$CFLAGS $1"
		shift;;

	-g)	CFLAGS="$CFLAGS -g"
		F2CFLAGS="$F2CFLAGS -g"
		shift;;

	-I)	CPPFLAGS="$CPPFLAGS -I$2"
		F2CFLAGS="$F2CFLAGS -I$2"
		shift 2
		;;

	-m)	CC="$CC -m$2"
		shift 2
		;;

	-U)	CPPFLAGS="$CPPFLAGS -U$2"
		shift 2
		;;

	-o)	OUTF=$2
		OUTO=$2
		shift 2
		;;

	-O)	case $2 in 1) O=-O1;; 2) O=-O2;; 3) O=-O3;; *) O=-O;; esac
		case $O in -O);; *) shift;; esac
		CFLAGS="$CFLAGS $O"
		shift
		;;

	-r)	case $2 in 8) F2CFLAGS="$F2CFLAGS -r8";;
			*) echo "Ignoring -r$2";; esac
		shift; shift
		;;

	-s)	strip=1
		shift
		;;

	-u)	F2CFLAGS="$F2CFLAGS -u"
		shift
		;;

	-w)	F2CFLAGS="$F2CFLAGS -w"
		case $2 in -6) F2CFLAGS="$F2CFLAGS"66; shift
			case $2 in -6) shift;; esac;; esac
		shift
		;;

	-L)	OFILES="$OFILES $1$2"
		shift 2
		case $cOPT in 1) cOPT=2;; esac
		;;

	-L*)	OFILES="$OFILES $1"
		shift
		case $cOPT in 1) cOPT=2;; esac
		;;

	-N)	F2CFLAGS="$F2CFLAGS $1""$2"
		shift 2
		;;

	-P)	F2CFLAGS="$F2CFLAGS $1"
		shift
		;;


	-S)	CFLAGS="$CFLAGS -S"
		cOPT=0
		shift
		;;

	-t)
		case $2 in
			rapuv)
				F2CFLAGS="$F2CFLAGS -trapuv"
				trapuv=1
#				LIBS="$LIBS -lfpe"
				shift 2;;
			*)
				echo "invalid parameter $1" 1>&2
				shift;;
			esac
		;;

	'')	echo $0: 'unexpected null argument'; exit 1;;

	*)
		FILES="$FILES $1"
		shift
		;;
	esac
done
if [ -z "$FILES" ]; then
	echo No input files for F77
	exit 1
fi
for i in $FILES
do
	case "$i"
	in
	*.[fF])
		if [ -z "$OUTO" -o "$cOPT" != "0" ]; then
			case "$i" in
			*.f)	OUTO=`basename $i .f`.o ;;
			*.F)	OUTO=`basename $i .F`.o ;;
			esac
		fi
		b=`dirname $OUTO`/`basename $OUTO .o`
		case "$i" in
			*.f)	$F2C $F2CFLAGS $i -o $b.c
				rc=$?
				;;
			*.F)	$CPP $CPPFLAGS $i >$b.i
				rc=$?
				if [ $rc = 0 ]; then
					$F2C $F2CFLAGS <$b.i >$b.c
					rc=$?
				fi
				rm $b.i
				;;
		esac
		if [ $rc != 0 ]; then exit; fi
                $CC -c $CFLAGSF2C $CFLAGS -o $OUTO $b.c 2>$s
		rc=$?
		sed '/parameter .* is not referenced/d;/warning: too many parameters/d' $s 1>&2
		if [ $rc != 0 ]; then exit; fi
		OFILES="$OFILES $OUTO"
		OUTO=""
		test -z "$keep_c_files" && rm $b.c
		if [ $cOPT = 1 ]; then cOPT=2; fi
		;;
	*.e)
		b=`basename $i .e`
		$EFL $EFLFLAGS $i >$b.f
		if [ "$?" != 0 ]; then rc=$?; exit; fi
		$F2C $F2CFLAGS $b.f
		if [ "$?" != 0 ]; then rc=$?; exit; fi
                $CC -c $CFLAGSF2C $CFLAGS $b.c
		if [ "$?" != 0 ]; then rc=$?; exit; fi
		OFILES="$OFILES $b.o"
		rm $b.[cf]
		if [ $cOPT = 1 ]; then cOPT=2; fi
		;;
	*.r)
		b=`basename $i .r`
		$RATFOR $RFLAGS $i >$b.f
		if [ "$?" != 0 ]; then rc=$?; exit; fi
		$F2C $F2CFLAGS $b.f
		if [ "$?" != 0 ]; then rc=$?; exit; fi
		$CC -c $CFLAGSF2C $CFLAGS $b.c
		if [ "$?" != 0 ]; then rc=$?; exit; fi
		OFILES="$OFILES $b.o"
		rm $b.[cf]
		if [ $cOPT = 1 ]; then cOPT=2; fi
		;;
	*.s)
		echo $i: 1>&2
		OFILE=`basename $i .s`.o
		${AS:-as} -o $OFILE $AFLAGS $i
		if [ "$?" != 0 ]; then rc=$?; exit; fi
		OFILES="$OFILES $OFILE"
		if [ $cOPT = 1 ]; then cOPT=2; fi
		;;
	*.c)
		echo $i: 1>&2
		OFILE=`basename $i .c`.o
                $CC -c $CFLAGSF2C $CPPFLAGS $CFLAGS $i
		if [ "$?" != 0 ]; then rc=$?; exit; fi
		OFILES="$OFILES $OFILE"
		if [ $cOPT = 1 ]; then cOPT=2; fi
		;;
	*.o)
		OFILES="$OFILES $i"
		if [ $cOPT = 1 ]; then cOPT=2; fi
		;;
	*.so)
		OFILES="$OFILES $i"
		if [ $cOPT = 1 ]; then cOPT=2; fi
		;;
	*.P)
		F2CFLAGS="$F2CFLAGS $i"
		;;
	*)
		OFILES="$OFILES $i"
		if [ $cOPT = 1 ]; then cOPT=2; fi
		;;
	esac
done

### On some (IRIX) systems, -Wl,-dont_warn_unused prevents complaints
### about unnecessary -l options.

case $cOPT in 2)
#	case $trapuv in 1) OFILES="$OFILES -lfpe";; esac
#	$CC -Wl,-dont_warn_unused -o $OUTF -u MAIN__ -L/usr/local/lib $OFILES $LIBS
#	$CC -o $OUTF -u MAIN__ -L/usr/local/lib $OFILES $LIBS
	$CC -o $OUTF -L/usr/local/lib $OFILES $LIBS
	case $strip in 1) strip $OUTF;; esac
	;; esac
rc=$?
exit $rc
